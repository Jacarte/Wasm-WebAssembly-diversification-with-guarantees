Add \texttt{type} 
%&  
\vspace{-4mm}
\begin{lstlisting}[numbers=none]{Name}
(module
  (type (;0;) (func (param i32) (result i64)))
        \end{lstlisting}   
%&  
%\vspace{-4mm}
LHS
\begin{lstlisting}[numbers=none]{Name}
(module
  (type (;0;) (func (param i32) (result i64)))
!+ (type (;0;) (func (param i64) (result i32 i64)))!
        \end{lstlisting}  
\hrulefill

RHS
\begin{lstlisting}[numbers=none]{Name}
(module
  (type (;0;) (func (param i32) (result i64)))
!+ (type (;0;) (func (param i64) (result i32 i64)))!
        \end{lstlisting}   
 %       \vspace{-4mm}
%&   S \\

%& \multicolumn{3}{l}{
%\begin{minipage}{0.9\textwidth}

    %\begin{tcolorbox}[boxrule=0.1pt,arc=.1em,boxsep=-1.5mm]
    %    \textbf{Guarantees:} The generated type is not duplicated. Recalculates type indexes. Notice that the new type is used during the compilation of the binary and not during runtime. Therefore, we can say that the state of the new program is the same as the original at any moment of its execution.
    %\end{tcolorbox}
%\end{minipage}
%} \\
%&
%$[St, S, L, Mi, Fi, Ti, M, G, E, I]$ &
%$[St, S, L, Mi, Fi, Ti, M, G, E, I]$ \\
%\hline